# Module:

## Attention

- Некоторые умозаключения были составлены при переходе с версии [1.7.9](https://github.com/xavetar/PHASEXave/tree/1.7.9) на [1.8.0](https://github.com/xavetar/PHASEXave/tree/1.8.0). Полное совпадение после этих версий не гарантированно, поэтому не стоит удивляться, если возникнет ощущение фрустрации и полного не понимая того, почему текст и код не совпадают.

## Presentation days

### [days.rs](../api/src/types/planets/earth/calendar/functions/days.rs)

```
Название было изменено с era_days_from_date на days_from_presentation_date, фактически мы получаем из результата
работы этой функции количество/сумму всех дней с представления даты в какой-то календарной системе, но в самом
представлении даты, могут находится дни другой эры, именно поэтому такое название было бы не совсем корректным.

В Юлианском календаре это дни 01.01.1 BCE и 02.01.1 BCE, таким образом по факту функция возвращает
не совсем дни эры, а дни представления даты в какой-то календарной системе. И этот результат ДОЛЖЕН
БЫТЬ скорректирован в функциях выше, для приведения к формату CE (Current Era) или BCE (Before Current Era)*.

Для Григорианского и Солнечного данные логические утверждения так-же верны, ведь правильное количество/сумма
дней для этой эры, является подмножеством презинтативной даты, зависящей от количества дней в году, не смотря
на то, что для этих календарей это ничего не меняет, для них можно считать что название функции так и осталось
era_days_from_date, т.к в них отсутствуют BCE (Before Current Era) дни.

* - данная функциональность ПОКА не реализована.
```

### [weak.rs](../api/src/types/planets/earth/calendar/constants/week.rs)

```
Названия констант были измененны с:

SHIFT_BEFORE_FIRST_WEEK_DAY_SOLAR => SHIFT_BEFORE_FIRST_PRESENTATION_WEEK_DAY_SOLAR
SHIFT_BEFORE_FIRST_WEEK_DAY_JULIAN => SHIFT_BEFORE_FIRST_PRESENTATION_WEEK_DAY_JULIAN
SHIFT_BEFORE_FIRST_WEEK_DAY_GREGORIAN => SHIFT_BEFORE_FIRST_PRESENTATION_WEEK_DAY_GREGORIAN

Почему? Потому-что представление даты из календаря, может содержать в себе дни с BCE (Before Common Era),
использование предыдущих названий было бы не совсем корректным и запутывающим, ведь использование
таких наименований подразумевает, что всё представление даты/календаря принадлежит к текущей эре
и вызывает побочные ложные умозаключения.

Дата представления, дата смещения от представления, не тоже самое, что дата в текущей эре,
дата представления может содержать в себе дни или смещения от дней другой эры. Она может быть
привязана к дням другой эры, для того чтобы сохранить когерентность календарной системы и её
совместимость с BCE (Before Common Era). Абстрактный год, содержит в себе дни и предыдущей эры
и текущей.
```

### [year.rs](../api/src/types/counter/unix_time/functions/year.rs)

```
Название было изменено с year_from_era_days на year_from_presentation_days, фактически мы получаем из
результата работы этой функции количество/сумму лет с представления даты в какой-то календарной системе,
но в самом представлении даты, могут находится дни другой эры, именно поэтому такое название было бы
не совсем корректным.

В Юлианском календаре это дни 01.01.1 BCE и 02.01.1 BCE, таким образом по факту функция возвращает
год, в представления даты в какой-то календарной системе.

Для Григорианского и Солнечного данные логические утверждения так-же верны, ведь правильное количество/сумма
лет для этой эры, является подмножеством презинтативной даты, зависящей от количества дней в году, не смотря
на то, что для этих календарей это ничего не меняет, для них можно считать что название функции так и осталось
year_from_era_days, т.к в них отсутствуют BCE (Before Current Era) дни/года.
```

## Era days

### [days.rs](../api/src/types/counter/unix_time/constants/days.rs)

```
День старта Unix time неизменнен, т.к день не зависит от представления даты, количество дней не изменно и
не зависимо от календаря их формул.
Любая дата - это абстракция, как и календарь, но день эры это абсолютная величина.

Согласно любому календарю день текущей эры ПОСЛЕ которого начинается отсчёт unix time - это 719162*.
Представление же дня эры* в Юлианском: 18.12.1969, в Григорианском: 31.12.1969, в Солнечном: 01.01.1970.

Стоит отметить, что Юлианское представление даты, содержит в себе 2 дня с BCE. 03.01.1 CE (Current era) по
Юлианскому календарю в своём представлении соответствует представлению 01.01.1 в Григорианском и Солнечном.
Если убрать из представления дни с BCE 1 год Юлианского календаря будет состоять из 363 дням, а Январь будет
содержать 29 дней. Эти BCE дни (01.01.1 BCE и 02.01.1 BCE) не должны включаться в расчёт дней текущей эры (CE).
Вопрос заключается в другом, допустимо ли использовать в представлении Юлианского календаря дни из BCE?

Таким образом фактически Юлианский календарь в текущей эре ДОЛЖЕН стартовать с Понедельника - 01.01.1 CE,
а получается с Понедельника - 03.01.1 CE (где 01.01.1 BCE и 02.01.1 BCE), что является мягко говоря
противоречивым, ведь эти два дня представления BCE находятся в представлении Юлианской даты CE.

Этих дней в идеале, не должно быть в представлении даты Юлианского календаря для CE, но в теории
для сохранения обратной совместимости - это может быть допустимым, но не должно быть запутывающим.
Ответа на вопрос почему было сделано так, нигде нет - его удалось понять только при попытке исправить
существующий алгоритм, ведь год состоящий из 363 дней, ломает совместимость и противоречит "модели"
года состоящего из 365/366 дней и ломает все существующие алгоримты (кроме этого, ахаха).

В идеальной реализации этого крейта, 1 год для Юлианского календаря должен состоять из 363 дней, а Январь
из 29 дней, ведь мы можем учитывать в представлении даты CE, дни находящиеся в BCE - это не вопрос удобства,
а вопрос логики, но при этом последующие годы будут идти в той-же модели из 365/366 дней, а дата после которой
начнёт считать unix time так и останется 18.12.1969 в Юлианском представлении даты.

Практически сделать это просто, но это увеличит количество кода, чтобы сохранить полную совместимость с BCE
и летоисчиление продолжилось, и сохранть при этом полную совместимость Юлианского представления даты BCE и CE
и не делая первый год состоящим из 363 дней, а Январь из 29 дней и сохранить совместимость с другими алгоритмами,
данные изменения ПОКА вноситься не будут.
```

## Leap Year

### [leap_year.rs](../api/src/types/planets/earth/calendar/functions/leap_year.rs)

```
- В Юлианском календаре:

Каждый 4-й год високосный, поэтому мы можем однозначно детерминировать високосный год,
взяв остаток от деления на 4.

Этот вид календаря давно потерял свою точность с точки зрения соотнесения представления календаря
и его даты с реальным временем года. Для остальных целей, если не важно представление даты и равенство
сезонов между годами, он подходит идеально. Всё равно из-за теории больших чисел он рано или поздно
вернётся к точке отсчёта сезонов и представления даты.

- В Григорианском календаре:

Каждый 4-й год високосный, за исключением года, который делится на 100 (без остатка),
при этом если год делится без остатка на 400 (кратен 400), год будет високосным (игнорируется правило 100).
Григорианский календарь, уже сейчас опережает тропический год на 1 день. Теория больших чисел говорит о том,
что бесполезно в динамической системе, использовать статические средства определения каких либо значений.
Григорианский календарь, либо закончит своё существование вставками, либо его заменит другой более точный
календарь.

- В Солнечном календаре:

Он же Тропический, в нём сложно или невозможно однозначно определить високосный год из-за большой
високосной части - 0.24219(...). И даже если это возможно, то расхождения представления календаря
и времён года - избежать будет крайне сложно. Поэтому единственный и самый гениальный вариант,
однозначного определения, идти от обратного (для этого нужен был инсайт).

К примеру, за первые 4-ре года в Солнечном/Тропическом календаре проходит:

4 * 0.24219 = 0.96876 (високосных дней)

Из-за чего 4-й год не может быть високосным - априори, но вот следующий за ним - вполне.

Как работает формула и почему она работает? Формула работает так:

1) Берёт текущий год, к примеру 5-й (year)
2) Берёт предыдущий год, 4-й
3) Вычисляет вещественное високосное значение для предыдущего года, 0.96876
4) Добавляет вещественную високосную часть (0.24219) от следующего года (5-й) к 0.96876,
   что равно 1.21095 (на конец 5-го года).
5) Сравнивает целые части:
5.1) Когда целая високосная часть следующего года (1), больше, чем за предыдущий год (0): 1 > 0, год високосный.

Таким образом точность календарной системы, теперь зависит только от констатны високосной части года, для
Солнечного календаря она определена как 0.24219(..). Что хорошо, так как это избавляет от ситуаций, при которых
делают вставки и одновременно кратно повышает точность календарной системы.
```

## Timezone

### [tz.rs](../api/src/types/planets/earth/calendar/traits/converter/tz.rs)

#### Signed Timezone:

```
1. Если временная зона отрицательна и количество секунд в последнем дне (по UTC - unix time) больше или равно,
чем во временной зоне, то отнимается количество секунд временной зоны, и прибавляется количество секунд за текущий день,
при этом количество дней не изменяется! era_days: [0, 0].

2. Если временная зона содержит больше (отрицательных по отношению к UTC) секунд и количество секунд в последнем дне (day_seconds)
меньше, чем во временной зоне (т.е это всегда от [-1, -N] дней к секундам по UTC - unix time), то вычисляется разница, между
временной зоной и секундами в текущем дне - разница потому-что эти секунды всегда идут вперёд, тем самым откусывая часть времени
от временной зоны вперёд, в результате разницы, получается значение/сумма секунд, на которое текущий день по UTC отходит назад по
unix time. Минимальное значение этой разницы 1 секунда (23:59:59) или 1 день назад. Деление с округлением вверх - это трюк и
попытка получить, абсолютную сумму дней отходящих назад. Причём это выражение всегда находится в пределе от [-1, -N] дней, по
отношению к дням эры/секундам от/по UTC, вне зависимости от временной зоны! era_days: [-1, -N].
После этого отнимается количество секунд временной зоны, и прибавляется количество секунд за текущий день.
```

#### Unsigned Timezone:

```
1. Если временная зона положительна (по отношению к UTC) и общая сумма секунд временной зоны (tz_sec) и последнем дне (day_seconds),
строго меньше/не превышает, максимальное количество секунд, требуемое для смены дня (SECONDS_IN_DAY) - день остаётся прежним,
при этом количество дней не изменяется! era_days: [0, 0].

2. Если временная зона положительна (по отношению к UTC) и общая сумма секунд временной зоны (tz_sec) и последнем дне (day_seconds),
больше/превышает или равна, минимальному значению требуемому для смены дня (SECONDS_IN_DAY), выполняется Евклидово деление
целочисленное/с округлением вниз - суммы секунд временной зоны (tz_sec) и последнем дне (day_seconds) на SECONDS_IN_DAY, с целью
узнать сумму дней превышения (т.е это всегда от [+1, +N] дней к секундам по UTC - unix time) и увеличивается количество дней эпохи
на это значение. Причём это выражение всегда находится в пределе от [+1, +N] дней, по отношению к дням эры/секундам от/по UTC, вне
зависимости от временной зоны! era_days: [+1, +N].
После этого прибавляется количество секунд временной зоны, и количество секунд за текущий день.
```